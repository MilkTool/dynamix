/*! \page advanced Advanced Topics

[TOC]

Performance {#performance}
===========

Message performance {#msg_perf}
-------------------

The performance of messages is indeed slower than regular function calls and even
virtual function calls. Even though a call's algorithmic complexity is still
O(1), a number of memory indirections happen in order to call the actual method
behind the message.

Unfortunately it's hard to estimate exactly how much slower the message call is.
With perfect cache locality and compiler optimizations a message call will take
several nanoseconds to execute on a modern CPU. It would be a bit slower than a
virtual vall and about as fast as a `std::function` call.

Unfortunately perfect cache locality is hard to come by, and especially hard in
polymorphic code. So, generally speaking if the programmer doesn't take special care to achieve
cache locality for their object lists, a message call is about 2-3 times slower
than a virtual method agaub about as fast a `std::function` call, which
again can be called negligible.

As, we've mentioned before if cache locality is an absolutely
critical feature for the desired performance, mixin messages, virtual calls,
`std::function`, and other types of polymorphism will almost certainly
be detrimental for this code, and the programmers are advised to do something
else.

Here is the assembly generated by gcc 7.1 for `int(int)` message call:

```
    push    rbp
    push    rbx
    mov     rbx, rdi
    xor     edi, edi
    mov     ebp, esi
    sub     rsp, 8
    call    _dynamix_get_mixin_feature_fast(feature*)
    ; if not exported from a shared library, the lines from above can be
    ; optimized away to an offset from rip with link time optimization

    ; call table entry
    mov     rax, QWORD PTR [rax]
    mov     rcx, QWORD PTR [rbx]
    mov     esi, ebp

    ; message data
    lea     rax, [rax+rax*2]
    mov     rdx, QWORD PTR [rcx+8208+rax*8]

    ; mixin data
    mov     rax, QWORD PTR [rdx+8]
    mov     rax, QWORD PTR [rcx+rax*8]

    ; prepare tailcall
    sal     rax, 4
    add     rax, QWORD PTR [rbx+8]
    mov     rdi, QWORD PTR [rax+8]
    mov     rax, QWORD PTR [rdx+16]
    add     rsp, 8
    pop     rbx
    pop     rbp
    jmp     rax ; tailcall to user code
```

### Message performance test

The message performance test compares virtual method
calls vs `std::function` calls vs DynaMix message calls.

For all tests a number of random objects of one of two possible types are
generated. The `noop` test calls a function with no arguments and no body,
measuring the time only. The `setter` test sets a member variable via a virtual
setter function.

The multicast tests create random objects of one of three possible types, which
all call three member polymorphic functions. Once again there's a `noop` test
with empty functions with no arguments and `setter` test with virtual setter
functions which set an integer.

In all example test the `std::function` implementation is chosen as a baseline
and the baseline column is the performance compared to it.

Here are some sample test results:

- OS: Ubuntu 16.04
- CPU: AMD FX X8 8150
- Compiler: gcc 5.4.0
- Compiler arguments: `-O3`

|   Name (baseline is *)   | Objects |  Total ms |  ns/op  |Baseline| Ops/second|
|--------------------------|---------|-----------|---------|--------|-----------|
|             virtual_noop |  200000 |     1.288 |       6 |  0.256 |155225270.7|
|          std_func_noop * |  200000 |     5.035 |      25 |      - | 39725820.3|
|                 msg_noop |  200000 |     3.118 |      15 |  0.619 | 64151747.1|
|           virtual_setter |  200000 |     1.540 |       7 |  0.254 |129892565.9|
|        std_func_setter * |  200000 |     6.070 |      30 |      - | 32951002.8|
|               msg_setter |  200000 |     4.509 |      22 |  0.743 | 44354926.3|
|     (multi) virtual_noop |  200000 |     5.326 |      26 |  0.282 | 37549680.6|
|  (multi) std_func_noop * |  200000 |    18.881 |      94 |      - | 10592822.0|
|         (multi) msg_noop |  200000 |     7.760 |      38 |  0.411 | 25774461.3|
|   (multi) virtual_setter |  200000 |     6.192 |      30 |  0.279 | 32298656.6|
|(multi) std_func_setter * |  200000 |    22.219 |     111 |      - |  9001301.1|
|       (multi) msg_setter |  200000 |     8.877 |      44 |  0.400 | 22529979.2|

- OS: Windows 10
- CPU: Intel Core i7 @ 2.3GHz
- Compiler: Visual C++ 14 (2015) Update 3
- Debug compilation parameters: Standard (`/Od /EHsc /RTC1 /MDd /ZI`)
- Compiler arguments: `/O2 /Ob2 /MD`

|   Name (baseline is *)   | Objects |  Total ms |  ns/op  |Baseline| Ops/second|
|--------------------------|---------|-----------|---------|--------|-----------|
|             virtual_noop |  200000 |     0.930 |       4 |  0.204 |215059082.1|
|          std_func_noop * |  200000 |     4.549 |      22 |      - | 43965397.5|
|                 msg_noop |  200000 |     2.841 |      14 |  0.625 | 70391577.8|
|           virtual_setter |  200000 |     1.212 |       6 |  0.146 |165015820.9|
|        std_func_setter * |  200000 |     8.302 |      41 |      - | 24089393.8|
|               msg_setter |  200000 |     4.561 |      22 |  0.549 | 43853542.3|
|     (multi) virtual_noop |  200000 |     4.115 |      20 |  0.331 | 48604622.1|
|  (multi) std_func_noop * |  200000 |    12.443 |      62 |      - | 16073708.9|
|         (multi) msg_noop |  200000 |     5.343 |      26 |  0.429 | 37429695.3|
|   (multi) virtual_setter |  200000 |     5.581 |      27 |  0.306 | 35837457.8|
|(multi) std_func_setter * |  200000 |    18.236 |      91 |      - | 10967410.0|
|       (multi) msg_setter |  200000 |     9.913 |      49 |  0.544 | 20175710.3|

### Optimizing message calls

The stand-alone functions generated for messages typically have an `if`
statement in them. It's there so as to throw an exception if none of the mixins
in an object implements the message. If you disable the library's exceptions
those `if`-s will be converted to `assert`-s (which in non-debug compilations
are simply ignored).

If you don't want to recompile the library with exceptions disabled, or if you
just want all other exceptions, but not these, you can disable the throwing of
exceptions from the message functions if you define `DYNAMIX_NO_MSG_THROW` *before*
including the DynaMix headers.

Note that if you disable the exceptions from the message functions, calling a
message on an object that doesn't implement it, will certainly lead to undefined
behavior and crashes.

Also have in mind, that removing the 'if'-s will improve the performance by only
a small amount of nanoseconds per message call on a modern CPU. Situations where
such a thing could be significant should be very very rare.

Mutation performance {#mutation_perf}
--------------------

An object mutation can be a relatively slow operation.

Every mutation will invoke all mutation rules registered within the system.
Their speed may vary and will depend on whether they end up changing the
mutation or not. If they do change it, some allocation may take place. Even if
they don't, each of them will be invoked by a virtual function and will have
at least one 'if' check (possibly more, depending on the mutation rule).

If the mutation ends up creating a new type &ndash; a mixin combination that hasn't
yet been met &ndash; this will also lead to the relatively slow process of
initializing the internal data structures for that type. This will lead to
some allocations and loops that generate the type's call table.

Even if the mutation doesn't generate a new type, it will have to find the
existing one, which is a hash table lookup with key a bitset of size
`DYNAMIX_MAX_MIXINS`.

Finally, the mutation will change the object (unless it happens to be an
identity mutation &ndash; adding and removing nothing). To change it it will have to
allocate new mixin data for it &ndash; an array of pointers to mixins, then
deallocate any mixins being removed and allocate any mixins being added, and
finally deallocate the old mixin data for the object.

### Optimizing mutations

Using `dynamix::object_type_template` or `dynamix::same_type_mutator` will perform the first steps
&ndash; the ones concerning the identification of the object's type &ndash; only once.

To reduce the allocations for the individual object's being mutated, you can add
custom allocators to some of the mixins or to the entire domain.

### Mutations performance test

The mutation performance test test creation of new objects and the mutation of
existing ones.

- **create_mutate** &ndash; Creation of objects with `dynamix::mutate`.
- **type_template** &ndash; Creation of objects with a `dynamix::object_type_template`.
- **type_template_alloc** &ndash; Mutation with a type template and a fast custom allocator.
- **mutation** &ndash; Mutation of objects with `dynamix::mutate`. Adding two mixins and
removing one.
- **same_type_mutator** &ndash; The same mutation using `dynamix::same_type_mutator`.
- **same_type_mutator_alloc** &ndash; The same mutation with `dynamix::same_type_mutator`
and a fast custom allocator.

Here are some sample test results:

- OS: Ubuntu 16.04
- CPU: AMD FX X8 8150
- Compiler: gcc 5.4.0
- Compiler arguments: `-O3`

|   Name (baseline is *)   | Objects |  Total ms |  ns/op  |Baseline| Ops/second|
|--------------------------|---------|-----------|---------|--------|-----------|
|          create_mutate * |   10000 |     9.810 |     981 |      - |  1019320.5|
|            type_template |   10000 |     3.728 |     372 |  0.380 |  2682686.2|
|      type_template_alloc |   10000 |     2.163 |     216 |  0.220 |  4623247.0|
|               mutation * |   10000 |     8.311 |     831 |      - |  1203170.2|
|        same_type_mutator |   10000 |     2.944 |     294 |  0.354 |  3397164.9|
|  same_type_mutator_alloc |   10000 |     1.336 |     133 |  0.161 |  7486296.3|


- OS: Windows 10
- CPU: Intel Core i7 @ 2.3GHz
- Compiler: Visual C++ 14 (2015) Update 3
- Debug compilation parameters: Standard (`/Od /EHsc /RTC1 /MDd /ZI`)
- Compiler arguments: `/O2 /Ob2 /MD`

|   Name (baseline is *)   | Objects |  Total ms |  ns/op  |Baseline| Ops/second|
|--------------------------|---------|-----------|---------|--------|-----------|
|          create_mutate * |   10000 |    16.103 |    1610 |      - |   620993.2|
|            type_template |   10000 |     5.468 |     546 |  0.340 |  1828722.2|
|      type_template_alloc |   10000 |     2.749 |     274 |  0.171 |  3637850.5|
|               mutation * |   10000 |    10.333 |    1033 |      - |   967747.5|
|        same_type_mutator |   10000 |     3.648 |     364 |  0.353 |  2741181.5|
|  same_type_mutator_alloc |   10000 |     1.688 |     168 |  0.163 |  5923647.7|


Thread safety {#thread_safety}
=============

Some functionalities of the library are purposefully not thread-safe so as to
avoid the synchronization overhead for users which don't need it. For those
it is possible to implement thread-safety in the client code.

- Querying objects (say with `has`, `get`, or `implements`) is thread-safe.
- Calling messages is thread-safe. As thread-safe as the underlying functions
of course.
- Copying objects is thread-safe. As thread-safe as the copy-constructors and
assignment operators of the mixins in those objects.
- Mutating different objects in different threads is thread-safe. *HOWEVER*
- Mutating the same object in multiple threads is **not** thread-safe. If you
need this, you can subclass object and have a mutex within your class, which
can be maintained by a mutation rule
- Mutating objects in some threads, while calling messages to *other* objects in
other threads is thread-safe. *HOWEVER*
- Mutating an object in one thread and calling messages for this object in
another is **not** thread-safe and, alas, it's hard to accomplish. If you
absolutely need this, our suggestion is to first add a mutex to each object by
inheriting it. Second, lock/unlock it via mutation rules. And, third, define
your own message macros, for your object type which also lock said mutex.

Using custom allocators {#using_allocators}
=======================

(For the complete, working source of this example see [allocators.cpp](https://github.com/iboB/dynamix/blob/master/tutorial/allocators.cpp))

%{tutorial_allocators}

Having messages with more arguments {#more_msg_arity}
===================================

Currently the maximum number of arguments you can have in a message is:
\verbinclude arity

There simply is no message declaration macro for messages with more. If you need
macros for messages with more arguments, you can do so, without having to
rebuild the library.

In your DynaMix installation, in the `gen` directory you will see a file,
named `arity`. It is a text file with a single number in it. Edit the file,
setting the number to whichever value you need. Then run the script
`gen_message_macros.rb` (you will need a Ruby interpreter to do so). It will
generate the file `include/dynamix/gen/message_macros.ipp` with macros for
messages with 0 to *arity* arguments.

If you use an include directory for DynaMix diferent from the one in your
installation, you will have to manually copy the newly generated message macros
file over the one you use.

Shared libraries and program plugins {#dynlibs}
====================================

As long as the library itself is shared (`.dll` on Windows or `.so` on Unix or
Linux) it's safe to use in an application that has shared libraries which use
DynaMix.

An interesting thing which you can accomplish with the library is to have
optional plugins &ndash; dynamic libraries that aren't linked with the executable
but may or may not be present, and if they are, they are being loaded
dynamically (with `LoadLibrary` or `dlopen`).

Such plugin may add a mutation rule for its special mixins, or export functions
that mutate objects.

For example this may be very useful for an engineering CAD system that could
potentially have many different optional plugins for its different needs. Say, a
plugin that extends the buildings with electrical wiring could simply mutate
objects, adding a mixin
mixin called `electrical_wiring` that contains the appropriate functionality.

There is only one thing you need to remember when you're exporting mixins or
messages from a dynamic library: to use the export macros:
`DYNAMIX_DECLARE_EXPORTED_MIXIN` and `DYNAMIX_EXPORTED_xxx_MESSAGE_N`. They
are exactly like their regular counterparts but for their first argument, which
is the compiler specific export symbol (`__declspec(dllexport)` for Visual
C++ or, say, `BOOST_SYMBOL_EXPORT` if you're using Boost).

[One of the examples](examples.html#multi_dll) that come with the
library illustrates how you can have the two types of dynamic libraries &ndash;
one which you link with, and one plugin.

Serializing objects {#serializing}
===================

(For the complete, working source of this example see [serialization.cpp](https://github.com/iboB/dynamix/blob/master/tutorial/serialization.cpp))

%{tutorial_serialization}

Implementation notes {#impl_notes}
====================

Here are some explanations that may help you make sense of the code of the
library if you need to read it:

The overall structure of the library is based on a main class called `domain`
which holds all registered mixins and messages, and keeps the type registry.

Mixin and feature registration {#registration}
------------------------------

The `DYNAMIX_DEFINE_MIXIN` macro instantiates a class that is similar to a
metafunction, as its only purpose is to globally instantiate itself, which in
turn will lead to `domain::register_mixin_type` being called.

It also generates a function that registers the mixin features.

`domain::register_mixin_type` is a template method and it will appropriately
fill a structure, containing the mixin type information &ndash; name, constructor,
destructor, id &ndash; and will also call the generated function that registers its
features.

The feature registration is composed of two parts: one global - to introduce the
feature to the domain, and local called for the specific mixin type being
registered. This means that a feature is globally registered multiple times -
once for each of its uses for a mixin type. The first of those times will give
it an id and fill the feature information structure appropriately. The other
global registrations of a feature will see that it has a valid id, and will
simply skip the rest of the code.

The local feature registration is performed by the class `feature_parser` that
has overloads for the supported mixin features: currently messages and
allocators. The allocator registration is simple. It just sets the allocator
member in the mixin type information structure to the appropriate value.

The message registration generates a caller function, based on the specific
mixin. This caller function is a specific instantiation of a template function
which is generated by the message declaration macros. Its template parameters
are the mixin type and the actual member function in the mixin. The caller is
then cast to `void (*)()` to be stored in a vector in the mixin type information
structure along with the caller functions for all of its messages.

This process of creating a caller function is based on the article
[The Impossibly Fast C++ Delegates](http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates)
by Sergey Ryazanov.

Mixin and message id-s {#mix_msg_ids}
----------------------

Each newly registered mixin and message get an id. The id-s are consecutive
indexes in arrays (of `mixin_type_info` and `message_t` respectively) in the
domain. Thus getting the information for a mixin or a message through its id
is a O(1) operation.

The maximum numbers of registered messages and mixins are fixed through the
constants `DYNAMIX_MAX_MIXINS` and `DYNAMIX_MAX_MESSAGES` in `config.hpp`.

This allows us to have fixed-size arrays for both in the domain and per object
type.

Mutation and type information {#mut_type_info}
-----------------------------

A new object type is initially identified via a bitset per mixin. The domain
contains an unordered (hash) map where the key is such a bitset, and the value
is an object type info.

The object type info consists of such a bitset (to mark which mixins are
available in this type), a compact vector of mixin type information structures
a cross indexing array (to indicate which mixin data is at which position in the
compact array), and a call table.

The call table plays the same role as the virtual table in C++. It's a fixed
size array for every message with non-null values for the messages that are
implemented by that type. An element of that array is of type
`call_table_entry`. This is a union that, based on whether the message is a
unicast or a multicast, will contain the message data or a begin and an end
for a buffer or message datas.

When a type is requested for an object, first it's checked whether such a
combination of mixins is an existing type. If not a new object type is created.
This fills the mixin information bitset, vector and cross indexing array and
then fills the call table. It will allocate a single buffer for all multicast
messages within that type. When filling the call table the type creation process
will choose the top priority unicast messages and sort the multicasts by
priority. It will throw an exception if same-priority unicasts exist.

After the type is available the object data needs to be filled. The object
consists of a pointer to its type and an array of the structure
`mixin_data_in_object`. This structure wraps a simple buffer that contains the
mixin instance and a pointer to the owning object right in front of it. This
is required for the need to get the owning object from within the code of the
mixin class (made through `dm_this` or `object_of`). Thus, getting the owning
object from the mixin is an offset from the `this` pointer.

Calling messages {#calling_msgs}
----------------

The message calling happens through the message functions which are generated
by the message declaration macros.

The call consists of the following steps:

- Get the message info through a function generated by the message definition
macro
- Get the call table entry for this message from the object's type
- Get the mixin info and the caller function from the call table entry
- Get the mixin pointer from the object, based on the mixin info
- Cast the caller function from `void (*)()` to the appropriate signature.
- Call the caller function for the mixin pointer.

For multicasts there is a `for` loop for the last four steps.

Macros rationale {#why_macros}
================

Many people, upon seeing DynaMix for the first time, have expressed a
concern with the seemingly excessive amount of macros the library's users are
required to write.

Mixin definition and declaration macros {#why_mixin_macros}
---------------------------------------

The mixin definition and declaration macros are often mentioned as easy to
remove, and indeed there is a way to reproduce almost all of their functionality
without any macros. However not all of it can be reproduced.

One of the key features those macros provide is the global instantiation.
Without them, the users will be required to provide explicit entry points for
their subsystems and dynamic libraries, where they will have to call some
mixin initialization functions. This is not as simple as it sounds. Here is a
list of downsides that such explicit entry points may introduce:

- They will be compilation dependency "focal points": All mixins classes
introduced by a subsystem would need to be visible from there, which means
recompilations on every change, and more maintenance for the code.
- The users will have to be extra careful not to add mixins to objects before
their initialization is called.
- Duplicated instances of the mixin data structures will exist in different
modules (executable and dynamic libraries). In order to deal with this, the
domain would need to store multiple copies of info for the same mixin. This will
add a small runtime cost to the message calls and mutations.

Message definition and declaration macros {#why_msg_macros}
-----------------------------------------

The message macros are most likely impossible to remove. Unlike the mixin ones,
each of them generates many lines of code. More than a hundred.

Probably the only way to remove them completely, would be to make the message
calls by string. This will cause the calls to make hash table look-ups
(or worse) and will prohibitively slow them down. Such a scenario will also
reflect on the way mixins are registerd. The mixin messages would have to be
set through something that resembles `std::bind` adding yet more complexity to
the user code.

External custom preprocessor {#external_moc}
----------------------------

Is is possible (and probably part of the future of the library) to create an
external tool that makes the user code a bit nicer. It would resemble
[The Meta-Object Compiler of Qt](http://qt-project.org/doc/qt-4.8/moc.html),
and similarly, would require a custom preprocessing step of the users' code.

Such a tool could theoretically solve more of the library's problems, like the
need to call `message(object)` instead of `object.message()` at the very least,
and many more...

Still, such an approach also has many opponents, as the code you write when you
use it becomes effectively not-C++, but something that can be called a C++
dialect.

*/
