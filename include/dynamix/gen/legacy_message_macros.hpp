// DynaMix
// Copyright (c) 2013-2018 Borislav Stanimirov, Zahary Karadjov
//
// Distributed under the MIT Software License
// See accompanying file LICENSE.txt or copy at
// https://opensource.org/licenses/MIT
//
// this file is automatically generated by a script
//


#define I_DYNAMIX_MESSAGE0_DECL(export, message_name, method_name, return_type, constness, message_mechanism ) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::message_t \
    { \
        typedef return_type (*caller_func)(void* ); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : ::dynamix::internal::message_t(I_DYNAMIX_PP_STRINGIZE(message_name), message_mechanism, false) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            static caller_func the_caller = [](void* _d_mixin ) -> return_type \
            { \
                constness Mixin* _d_m = reinterpret_cast<Mixin*>(_d_mixin); \
                return _d_m->method_name(); \
            }; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * I_DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define I_DYNAMIX_MESSAGE0_UNI(export, message_name, method_name, return_type, constness ) \
    I_DYNAMIX_MESSAGE0_DECL(export, message_name, method_name, return_type, constness, unicast ) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj ) \
    {\
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::unicast); \
        const ::dynamix::internal::object_type_info::call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message& _d_msg = _d_call_entry.top_bid_message; \
        DYNAMIX_MSG_THROW_UNLESS(!!_d_msg, ::dynamix::bad_message_call); \
        /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
        char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
        /* forward unicast arguments since some of them might be rvalue references */ \
        return _d_func(_d_mixin_data ); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj ) \
    {\
        return method_name(*_d_obj ); \
    }\

#define I_DYNAMIX_MESSAGE0_MULTI(export, message_name, method_name, return_type, constness ) \
    I_DYNAMIX_MESSAGE0_DECL(export, message_name, method_name, return_type, constness, multicast ) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , Combinator& _d_combinator) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        ::dynamix::internal::set_num_results_for(_d_combinator, size_t(_d_end - _d_begin)); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message& _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            if(!_d_combinator.add_result(_d_func(_d_mixin_data ))) \
            { \
                return; \
            } \
        } \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj ) \
    { \
        Combinator<return_type> _d_combinator; \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        method_name(_d_obj , _d_combinator); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj ) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message&  _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            _d_func(_d_mixin_data ); \
        } \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj ) \
    {\
        method_name(*_d_obj ); \
    }\


#define I_DYNAMIX_MESSAGE1_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::message_t \
    { \
        typedef return_type (*caller_func)(void* , arg0_type); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : ::dynamix::internal::message_t(I_DYNAMIX_PP_STRINGIZE(message_name), message_mechanism, false) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            static caller_func the_caller = [](void* _d_mixin , arg0_type a0) -> return_type \
            { \
                constness Mixin* _d_m = reinterpret_cast<Mixin*>(_d_mixin); \
                return _d_m->method_name(std::forward<arg0_type>(a0)); \
            }; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * I_DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define I_DYNAMIX_MESSAGE1_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0) \
    I_DYNAMIX_MESSAGE1_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0) \
    {\
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::unicast); \
        const ::dynamix::internal::object_type_info::call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message& _d_msg = _d_call_entry.top_bid_message; \
        DYNAMIX_MSG_THROW_UNLESS(!!_d_msg, ::dynamix::bad_message_call); \
        /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
        char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
        /* forward unicast arguments since some of them might be rvalue references */ \
        return _d_func(_d_mixin_data , std::forward<arg0_type>(a0)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0) \
    {\
        return method_name(*_d_obj , std::forward<arg0_type>(a0)); \
    }\

#define I_DYNAMIX_MESSAGE1_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0) \
    I_DYNAMIX_MESSAGE1_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, Combinator& _d_combinator) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        ::dynamix::internal::set_num_results_for(_d_combinator, size_t(_d_end - _d_begin)); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message& _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            if(!_d_combinator.add_result(_d_func(_d_mixin_data , a0))) \
            { \
                return; \
            } \
        } \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0) \
    { \
        Combinator<return_type> _d_combinator; \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        method_name(_d_obj , a0, _d_combinator); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message&  _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            _d_func(_d_mixin_data , a0); \
        } \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0) \
    {\
        method_name(*_d_obj , std::forward<arg0_type>(a0)); \
    }\


#define I_DYNAMIX_MESSAGE2_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::message_t \
    { \
        typedef return_type (*caller_func)(void* , arg0_type, arg1_type); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : ::dynamix::internal::message_t(I_DYNAMIX_PP_STRINGIZE(message_name), message_mechanism, false) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            static caller_func the_caller = [](void* _d_mixin , arg0_type a0, arg1_type a1) -> return_type \
            { \
                constness Mixin* _d_m = reinterpret_cast<Mixin*>(_d_mixin); \
                return _d_m->method_name(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
            }; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * I_DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define I_DYNAMIX_MESSAGE2_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1) \
    I_DYNAMIX_MESSAGE2_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1) \
    {\
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::unicast); \
        const ::dynamix::internal::object_type_info::call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message& _d_msg = _d_call_entry.top_bid_message; \
        DYNAMIX_MSG_THROW_UNLESS(!!_d_msg, ::dynamix::bad_message_call); \
        /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
        char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
        /* forward unicast arguments since some of them might be rvalue references */ \
        return _d_func(_d_mixin_data , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1) \
    {\
        return method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
    }\

#define I_DYNAMIX_MESSAGE2_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1) \
    I_DYNAMIX_MESSAGE2_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, Combinator& _d_combinator) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        ::dynamix::internal::set_num_results_for(_d_combinator, size_t(_d_end - _d_begin)); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message& _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            if(!_d_combinator.add_result(_d_func(_d_mixin_data , a0, a1))) \
            { \
                return; \
            } \
        } \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1) \
    { \
        Combinator<return_type> _d_combinator; \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        method_name(_d_obj , a0, a1, _d_combinator); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message&  _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            _d_func(_d_mixin_data , a0, a1); \
        } \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1) \
    {\
        method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
    }\


#define I_DYNAMIX_MESSAGE3_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::message_t \
    { \
        typedef return_type (*caller_func)(void* , arg0_type, arg1_type, arg2_type); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : ::dynamix::internal::message_t(I_DYNAMIX_PP_STRINGIZE(message_name), message_mechanism, false) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            static caller_func the_caller = [](void* _d_mixin , arg0_type a0, arg1_type a1, arg2_type a2) -> return_type \
            { \
                constness Mixin* _d_m = reinterpret_cast<Mixin*>(_d_mixin); \
                return _d_m->method_name(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
            }; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * I_DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define I_DYNAMIX_MESSAGE3_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    I_DYNAMIX_MESSAGE3_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    {\
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::unicast); \
        const ::dynamix::internal::object_type_info::call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message& _d_msg = _d_call_entry.top_bid_message; \
        DYNAMIX_MSG_THROW_UNLESS(!!_d_msg, ::dynamix::bad_message_call); \
        /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
        char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
        /* forward unicast arguments since some of them might be rvalue references */ \
        return _d_func(_d_mixin_data , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    {\
        return method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
    }\

#define I_DYNAMIX_MESSAGE3_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    I_DYNAMIX_MESSAGE3_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, Combinator& _d_combinator) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        ::dynamix::internal::set_num_results_for(_d_combinator, size_t(_d_end - _d_begin)); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message& _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            if(!_d_combinator.add_result(_d_func(_d_mixin_data , a0, a1, a2))) \
            { \
                return; \
            } \
        } \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    { \
        Combinator<return_type> _d_combinator; \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        method_name(_d_obj , a0, a1, a2, _d_combinator); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message&  _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            _d_func(_d_mixin_data , a0, a1, a2); \
        } \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    {\
        method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
    }\


#define I_DYNAMIX_MESSAGE4_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::message_t \
    { \
        typedef return_type (*caller_func)(void* , arg0_type, arg1_type, arg2_type, arg3_type); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : ::dynamix::internal::message_t(I_DYNAMIX_PP_STRINGIZE(message_name), message_mechanism, false) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            static caller_func the_caller = [](void* _d_mixin , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) -> return_type \
            { \
                constness Mixin* _d_m = reinterpret_cast<Mixin*>(_d_mixin); \
                return _d_m->method_name(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
            }; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * I_DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define I_DYNAMIX_MESSAGE4_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    I_DYNAMIX_MESSAGE4_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    {\
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::unicast); \
        const ::dynamix::internal::object_type_info::call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message& _d_msg = _d_call_entry.top_bid_message; \
        DYNAMIX_MSG_THROW_UNLESS(!!_d_msg, ::dynamix::bad_message_call); \
        /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
        char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
        /* forward unicast arguments since some of them might be rvalue references */ \
        return _d_func(_d_mixin_data , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    {\
        return method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
    }\

#define I_DYNAMIX_MESSAGE4_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    I_DYNAMIX_MESSAGE4_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, Combinator& _d_combinator) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        ::dynamix::internal::set_num_results_for(_d_combinator, size_t(_d_end - _d_begin)); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message& _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            if(!_d_combinator.add_result(_d_func(_d_mixin_data , a0, a1, a2, a3))) \
            { \
                return; \
            } \
        } \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    { \
        Combinator<return_type> _d_combinator; \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        method_name(_d_obj , a0, a1, a2, a3, _d_combinator); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message&  _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            _d_func(_d_mixin_data , a0, a1, a2, a3); \
        } \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    {\
        method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
    }\


#define I_DYNAMIX_MESSAGE5_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::message_t \
    { \
        typedef return_type (*caller_func)(void* , arg0_type, arg1_type, arg2_type, arg3_type, arg4_type); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : ::dynamix::internal::message_t(I_DYNAMIX_PP_STRINGIZE(message_name), message_mechanism, false) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            static caller_func the_caller = [](void* _d_mixin , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) -> return_type \
            { \
                constness Mixin* _d_m = reinterpret_cast<Mixin*>(_d_mixin); \
                return _d_m->method_name(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
            }; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * I_DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define I_DYNAMIX_MESSAGE5_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    I_DYNAMIX_MESSAGE5_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    {\
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::unicast); \
        const ::dynamix::internal::object_type_info::call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message& _d_msg = _d_call_entry.top_bid_message; \
        DYNAMIX_MSG_THROW_UNLESS(!!_d_msg, ::dynamix::bad_message_call); \
        /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
        char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
        /* forward unicast arguments since some of them might be rvalue references */ \
        return _d_func(_d_mixin_data , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    {\
        return method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
    }\

#define I_DYNAMIX_MESSAGE5_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    I_DYNAMIX_MESSAGE5_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, Combinator& _d_combinator) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        ::dynamix::internal::set_num_results_for(_d_combinator, size_t(_d_end - _d_begin)); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message& _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            if(!_d_combinator.add_result(_d_func(_d_mixin_data , a0, a1, a2, a3, a4))) \
            { \
                return; \
            } \
        } \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    { \
        Combinator<return_type> _d_combinator; \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        method_name(_d_obj , a0, a1, a2, a3, a4, _d_combinator); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message&  _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            _d_func(_d_mixin_data , a0, a1, a2, a3, a4); \
        } \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    {\
        method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
    }\


#define I_DYNAMIX_MESSAGE6_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::message_t \
    { \
        typedef return_type (*caller_func)(void* , arg0_type, arg1_type, arg2_type, arg3_type, arg4_type, arg5_type); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : ::dynamix::internal::message_t(I_DYNAMIX_PP_STRINGIZE(message_name), message_mechanism, false) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            static caller_func the_caller = [](void* _d_mixin , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) -> return_type \
            { \
                constness Mixin* _d_m = reinterpret_cast<Mixin*>(_d_mixin); \
                return _d_m->method_name(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
            }; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * I_DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define I_DYNAMIX_MESSAGE6_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    I_DYNAMIX_MESSAGE6_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    {\
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::unicast); \
        const ::dynamix::internal::object_type_info::call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message& _d_msg = _d_call_entry.top_bid_message; \
        DYNAMIX_MSG_THROW_UNLESS(!!_d_msg, ::dynamix::bad_message_call); \
        /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
        char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
        I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
        /* forward unicast arguments since some of them might be rvalue references */ \
        return _d_func(_d_mixin_data , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    {\
        return method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
    }\

#define I_DYNAMIX_MESSAGE6_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    I_DYNAMIX_MESSAGE6_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5, Combinator& _d_combinator) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        ::dynamix::internal::set_num_results_for(_d_combinator, size_t(_d_end - _d_begin)); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message& _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            if(!_d_combinator.add_result(_d_func(_d_mixin_data , a0, a1, a2, a3, a4, a5))) \
            { \
                return; \
            } \
        } \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    { \
        Combinator<return_type> _d_combinator; \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        method_name(_d_obj , a0, a1, a2, a3, a4, a5, _d_combinator); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    { \
        const ::dynamix::feature& _d_self = _dynamix_get_mixin_feature_fast(static_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*>(nullptr)); \
        DYNAMIX_ASSERT(static_cast<const ::dynamix::internal::message_t&>(_d_self).mechanism == ::dynamix::internal::message_t::multicast); \
        typedef ::dynamix::internal::object_type_info::call_table_entry call_table_entry; \
        const call_table_entry& _d_call_entry = _d_obj._type_info->_call_table[_d_self.id]; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_begin = _d_call_entry.begin; \
        const ::dynamix::internal::object_type_info::call_table_message* _d_end = _d_call_entry.end; \
        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(_d_begin, ::dynamix::bad_message_call); \
        for(const ::dynamix::internal::object_type_info::call_table_message* _d_iter = _d_begin; _d_iter!=_d_end; ++_d_iter) \
        { \
            const ::dynamix::internal::object_type_info::call_table_message&  _d_msg = *_d_iter; \
            DYNAMIX_ASSERT(!!_d_msg); \
            /* unfortunately we can't assert(_d_msg.data->message == &_d_self); since the data might come from a different module */ \
            char* _d_mixin_data = reinterpret_cast<char*>(const_cast<void*>(_d_obj._mixin_data[_d_msg.mixin_index].mixin())); \
            I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func _d_func = \
                reinterpret_cast<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::caller_func>(_d_msg.caller); \
            /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
            _d_func(_d_mixin_data , a0, a1, a2, a3, a4, a5); \
        } \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    {\
        method_name(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
    }\

#include "arity_message_macros.hpp"
