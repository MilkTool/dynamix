// DynaMix
// Copyright (c) 2013-2019 Borislav Stanimirov, Zahary Karadjov
//
// Distributed under the MIT Software License
// See accompanying file LICENSE.txt or copy at
// https://opensource.org/licenses/MIT
//
#pragma once

#include "../config.hpp"
#include "../message.hpp"
#include "../exception.hpp"
#include "../object_type_info.hpp"
#include "assert.hpp"

namespace dynamix
{
namespace internal
{

// defines calling function
template <typename Ret, typename... Args>
struct msg_caller
{
    using caller_func = Ret (*)(void*, Args...);
};

// instead of adding the multi and unicast calls in the same struct, we split it in two
// thus multicast messages, won't also instantiate and compile the unicast call and vice-versa

// caller struct instantiated by message macros
// Derived - the msg class generated by macro, sent via crtp
// Object - dynamix::object but having the appropriate constness
// Ret and Args - message signature
template <typename Derived, typename Object, typename Ret, typename... Args>
struct msg_unicast : public message_t, public msg_caller<Ret, Args...>
{
    msg_unicast(const char* message_name)
        : message_t(message_name, message_t::unicast, false)
    {}

    static Ret make_call(Object& obj, Args&&... args)
    {
        const ::dynamix::feature& self = _dynamix_get_mixin_feature_fast(static_cast<Derived*>(nullptr));
        I_DYNAMIX_ASSERT(static_cast<const message_t&>(self).mechanism
            == message_t::unicast);

        const object_type_info::call_table_entry& call_entry =
            obj._type_info->_call_table[self.id];

        const object_type_info::call_table_message& msg = call_entry.top_bid_message;
        DYNAMIX_MSG_THROW_UNLESS(!!msg, ::dynamix::bad_message_call);

        // unfortunately we can't assert(msg_data.data->message == &self); since the data might come from a different module

        // skipping several function calls, which greatly improves build time
        char* mixin_data = reinterpret_cast<char*>(const_cast<void*>(obj._mixin_data[msg.mixin_index].mixin()));

        auto func = reinterpret_cast<typename msg_caller<Ret, Args...>::caller_func>(msg.caller);

        return func(mixin_data, std::forward<Args>(args)...);
    }
};

// caller struct instantiated by message macros
// Derived - the msg class generated by macro, sent via crtp
// Object - dynamix::object but having the appropriate constness
// Ret and Args - message signature
template <typename Derived, typename Object, typename Ret, typename... Args>
struct msg_multicast : public message_t, public msg_caller<Ret, Args...>
{
    msg_multicast(const char* message_name)
        : message_t(message_name, message_t::multicast, false)
    {}

    template <typename Combinator>
    static void make_combinator_call(Object& obj, Combinator& combinator, Args&... args)
    {
        const ::dynamix::feature& self = _dynamix_get_mixin_feature_fast(static_cast<Derived*>(nullptr));
        I_DYNAMIX_ASSERT(static_cast<const message_t&>(self).mechanism
            == message_t::multicast);

        const object_type_info::call_table_entry& call_entry =
            obj._type_info->_call_table[self.id];

        auto begin = call_entry.begin;
        auto end = call_entry.end;

        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(begin, ::dynamix::bad_message_call);

        set_num_results_for(combinator, size_t(end - begin));
        for (auto iter = begin; iter != end; ++iter)
        {
            auto& msg = *iter;
            I_DYNAMIX_ASSERT(!!msg);

            // unfortunately we can't assert(msg_data->message == &self); since the data might come from a different module

            // skipping several function calls, which greatly improves build time
            char* mixin_data = reinterpret_cast<char*>(const_cast<void*>(obj._mixin_data[msg.mixin_index].mixin()));

            auto func = reinterpret_cast<typename msg_caller<Ret, Args...>::caller_func>(msg.caller);

            if (!combinator.add_result(func(mixin_data, args...)))
            {
                return;
            }
        }
    }

    // the folowing copy-pasted overload will be obsolete with c++17
    // its only point is to support void multicast messages
    // otherwise we would be able to use a combinator like this for all
    // struct noop_combinator
    // {
    //     template <typename R>
    //     constexpr bool add_result(R&& r) const { return true; }
    // };
    // with c++17 we would be able to add if constexpr(is_same(void, Ret)) to make it work
    static void make_call(Object& obj, Args&... args)
    {
        const ::dynamix::feature& self = _dynamix_get_mixin_feature_fast(static_cast<Derived*>(nullptr));
        I_DYNAMIX_ASSERT(static_cast<const message_t&>(self).mechanism
            == message_t::multicast);

        const object_type_info::call_table_entry& call_entry =
            obj._type_info->_call_table[self.id];

        auto begin = call_entry.begin;
        auto end = call_entry.end;

        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(begin, ::dynamix::bad_message_call);

        for (auto iter = begin; iter != end; ++iter)
        {
            auto& msg = *iter;
            I_DYNAMIX_ASSERT(!!msg);

            // unfortunately we can't assert(msg_data->message == &self); since the data might come from a different module

            // skipping several function calls, which greatly improves build time
            char* mixin_data = reinterpret_cast<char*>(const_cast<void*>(obj._mixin_data[msg.mixin_index].mixin()));

            auto func = reinterpret_cast<typename msg_caller<Ret, Args...>::caller_func>(msg.caller);

            func(mixin_data, args...);
        }
    }
};
} // namespace internal
} // namespace dynamix


