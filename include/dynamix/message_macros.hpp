// DynaMix
// Copyright (c) 2013-2018 Borislav Stanimirov, Zahary Karadjov
//
// Distributed under the MIT Software License
// See accompanying file LICENSE.txt or copy at
// https://opensource.org/licenses/MIT
//
#pragma once


/**
 * \file
 * Macros used to declare and define messages.
 */


#include "message.hpp"
#include "preprocessor.hpp"
#include "exception.hpp"
#include "domain.hpp"

namespace dynamix
{
namespace internal
{
// classes instantiated by the message macros

// type used to register messages in case no mixin implements them
// (all mixins which implement a message will also register it)
template <typename Message>
struct message_registrator
{
    message_registrator()
    {
        _dynamix_register_mixin_feature(static_cast<Message*>(nullptr));
    }

    // defined in message_macros because it depends on domain.hpp
    // unregisteres the message
    ~message_registrator()
    {
        internal::domain::safe_instance().
            unregister_feature(static_cast<message_t&>(_dynamix_get_mixin_feature_safe(static_cast<Message*>(nullptr))));
    }

    // "payload" instance of the type
    static message_registrator registrator;

    // as with mixin_type_info_instance, this is
    // to prevent warnings and optimizations that will say that we're not using
    // instantiator by simply referencing it
    int unused;
};
template <typename Message>
message_registrator<Message> message_registrator<Message>::registrator;

// defines calling function
template <typename Ret, typename... Args>
struct msg_caller
{
    using caller_func = Ret (*)(void*, Args...);
};

// instead of adding the multi and unicast calls in the same struct, we split it in two
// thus multicast messages, won't also instantiate and compile the unicast call and vice-versa

// caller struct instantiated by message macros
// Derived - the msg class generated by macro, sent via crtp
// Object - dynamix::object but having the appropriate constness
// Ret and Args - message signature
template <typename Derived, typename Object, typename Ret, typename... Args>
struct msg_unicast : public message_t, public msg_caller<Ret, Args...>
{
    msg_unicast(const char* message_name)
        : message_t(message_name, unicast, false)
    {}

    static Ret make_call(Object& obj, Args&&... args)
    {
        const ::dynamix::feature& self = _dynamix_get_mixin_feature_fast(static_cast<Derived*>(nullptr));
        I_DYNAMIX_ASSERT(static_cast<const message_t&>(self).mechanism
            == message_t::unicast);

        const object_type_info::call_table_entry& call_entry =
            obj._type_info->_call_table[self.id];

        const object_type_info::call_table_message& msg = call_entry.top_bid_message;
        DYNAMIX_MSG_THROW_UNLESS(!!msg, ::dynamix::bad_message_call);

        // unfortunately we can't assert(msg_data.data->message == &self); since the data might come from a different module

        // skipping several function calls, which greatly improves build time
        char* mixin_data = reinterpret_cast<char*>(const_cast<void*>(obj._mixin_data[msg.mixin_index].mixin()));

        auto func = reinterpret_cast<typename msg_caller<Ret, Args...>::caller_func>(msg.caller);

        return func(mixin_data, std::forward<Args>(args)...);
    }
};

// caller struct instantiated by message macros
// Derived - the msg class generated by macro, sent via crtp
// Object - dynamix::object but having the appropriate constness
// Ret and Args - message signature
template <typename Derived, typename Object, typename Ret, typename... Args>
struct msg_multicast : public message_t, public msg_caller<Ret, Args...>
{
    msg_multicast(const char* message_name)
        : message_t(message_name, message_t::multicast, false)
    {}

    template <typename Combinator>
    static void make_combinator_call(Object& obj, Combinator& combinator, Args&... args)
    {
        const ::dynamix::feature& self = _dynamix_get_mixin_feature_fast(static_cast<Derived*>(nullptr));
        I_DYNAMIX_ASSERT(static_cast<const message_t&>(self).mechanism
            == message_t::multicast);

        const object_type_info::call_table_entry& call_entry =
            obj._type_info->_call_table[self.id];

        auto begin = call_entry.begin;
        auto end = call_entry.end;

        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(begin, ::dynamix::bad_message_call);

        set_num_results_for(combinator, size_t(end - begin));
        for (auto iter = begin; iter != end; ++iter)
        {
            auto& msg = *iter;
            I_DYNAMIX_ASSERT(!!msg);

            // unfortunately we can't assert(msg_data->message == &self); since the data might come from a different module

            // skipping several function calls, which greatly improves build time
            char* mixin_data = reinterpret_cast<char*>(const_cast<void*>(obj._mixin_data[msg.mixin_index].mixin()));

            auto func = reinterpret_cast<typename msg_caller<Ret, Args...>::caller_func>(msg.caller);

            if (!combinator.add_result(func(mixin_data, args...)))
            {
                return;
            }
        }
    }

    // the folowing copy-pasted overload will be obsolete with c++17
    // its only point is to support void multicast messages
    // otherwise we would be able to use a combinator like this for all
    // struct noop_combinator
    // {
    //     template <typename R>
    //     constexpr bool add_result(R&& r) const { return true; }
    // };
    // with c++17 we would be able to add if constexpr(is_same(void, Ret)) to make it work
    static void make_call(Object& obj, Args&... args)
    {
        const ::dynamix::feature& self = _dynamix_get_mixin_feature_fast(static_cast<Derived*>(nullptr));
        I_DYNAMIX_ASSERT(static_cast<const message_t&>(self).mechanism
            == message_t::multicast);

        const object_type_info::call_table_entry& call_entry =
            obj._type_info->_call_table[self.id];

        auto begin = call_entry.begin;
        auto end = call_entry.end;

        DYNAMIX_MULTICAST_MSG_THROW_UNLESS(begin, ::dynamix::bad_message_call);

        for (auto iter = begin; iter != end; ++iter)
        {
            auto& msg = *iter;
            I_DYNAMIX_ASSERT(!!msg);

            // unfortunately we can't assert(msg_data->message == &self); since the data might come from a different module

            // skipping several function calls, which greatly improves build time
            char* mixin_data = reinterpret_cast<char*>(const_cast<void*>(obj._mixin_data[msg.mixin_index].mixin()));

            auto func = reinterpret_cast<typename msg_caller<Ret, Args...>::caller_func>(msg.caller);

            func(mixin_data, args...);
        }
    }
};
}
}

/// \internal
#define I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) I_DYNAMIX_PP_CAT(dynamix_msg_, message_name)
/// \internal
#define I_DYNAMIX_MESSAGE_TAG(message_name) I_DYNAMIX_PP_CAT(message_name, _msg)
/// \internal
#define I_DYNAMIX_MESSAGE_CALLER_STRUCT(mechanism) I_DYNAMIX_PP_CAT(msg_, mechanism)

// default impl helper macros

// name of default implementation struct
/// \internal
#define DYNAMIX_DEFAULT_IMPL_STRUCT(message_name) I_DYNAMIX_PP_CAT(message_name, _default_impl_t)

// no-arity macros

// macro which gives out a sensible error if a no-arity macro is called with a bad number of arguments
/// \internal
#define I_DYNAMIX_MESSAGE_ARG_ERROR static_assert(false, "DynaMix macro called with a bad number of arguments")

// a workaround to a visaul c issue which doesn't expand __VA_ARGS__ but inead gives them as a single argument
/// \internal
#define I_DYNAMIX_VA_ARGS_PROXY(MACRO, args) MACRO args

#if defined(DYNAMIX_DOXYGEN)
// use these macros for the docs only

/**
* Macro that declares a message
*
* This generates the stand-alone function which is users should use to call messages.
*
* The calls will throw the exception `bad_message_call` if none of the mixins
* from which the object is composed handles this message. To prevent the message calls
* from Throwing exceptions you can define `DYNAMIX_NO_MSG_THROW` before including
* the library's headers.
*
* \par Variants:
* \code
* DYNAMIX_MESSAGE_N(return_type, message, args)
* DYNAMIX_CONST_MESSAGE_N(return_type, message, args)
* DYNAMIX_MULTICAST_MESSAGE_N(return_type, message, args)
* DYNAMIX_CONST_MULTICAST_MESSAGE_N(return_type, message, args)
* DYNAMIX_EXPORTED_MESSAGE_N(export, return_type, message, args)
* DYNAMIX_EXPORTED_CONST_MESSAGE_N(export, return_type, message, args)
* DYNAMIX_EXPORTED_MULTICAST_MESSAGE_N(export, return_type, message, args)
* DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_N(export, return_type, message, args)
* DYNAMIX_MESSAGE_N_OVERLOAD(message_name, return_type, method_name, args)
* DYNAMIX_CONST_MESSAGE_N_OVERLOAD(message_name, return_type, method_name, args)
* DYNAMIX_MULTICAST_MESSAGE_N_OVERLOAD(message_name, return_type, method_name, args)
* DYNAMIX_CONST_MULTICAST_MESSAGE_N_OVERLOAD(message_name, return_type, method_name, args)
* DYNAMIX_EXPORTED_MESSAGE_N_OVERLOAD(export, message_name, return_type, method_name, args)
* DYNAMIX_EXPORTED_CONST_MESSAGE_N_OVERLOAD(export, message_name, return_type, method_name, args)
* DYNAMIX_EXPORTED_MULTICAST_MESSAGE_N_OVERLOAD(export, message_name, return_type, method_name, args)
* DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_N_OVERLOAD(export, message_name, return_type, method_name, args)
* \endcode
*
* \par Legend:
* - `N` in those variant names is a number that indicates how many parameters the
* message takes. If `N` is 0, then `args` is omitted.
* - `args` is a coma-separated list of the argument types and argument names of
* the message's arguments
* - If `MULTICAST` is a part of a macro, it declares a multicast message. Otherwise
* it declares a unicast message.
* - If `CONST` is part of a macro, then the message works with `const object&` and
* should be bound to const methods of a mixin class. Otherwise it works with simply
* `object&` and should be bound no non-const methods of the mixin class.
* - If `EXPORTED` is part of a macro, then it's used to declare a message that is
* exported from a dynamic library. The `export` parameter should be the appropriate
* export/import symbols for the particular compiler (i.e. `__declspec(dllexport)`)
* - If `OVERLOAD` is part of a macro, it defines a message overload. It splits the
* ways of referring to the message in two. The first - `message_name` - should be
* used when referring to the message - in mixin feature lists, in
* `object::implements`, and in `DYNAMIX_DEFINE_MESSAGE`. The second -
* `method_name` - is the name of the method in the mixin class, and will be the
* name of the message function generated by the macro.
*
* \par Examples:
* \code
*
* // A basic non-const unicast message with no arguments.
* // Should be bound to: void mixin_class::foo()
* DYNAMIX_MESSAGE_0(void, foo);
*
* // A const multicast message with two arguments
* // Should be bound to: void mixin_class::serialize(archive& ar, int flags) const
* DYNAMIX_CONST_MULTICAST_MESSAGE_2(void, serialize, archive&, ar, int, flags);
*
* // Assuming MY_LIB_API is a macro that expands accordingly to the
* // export/import symbols for the compiler you're using, this is
* // a const unicast message with one argument exported from a dynamic library
* // Should be bound to: float mixin_class::size(int dimension) const
* DYNAMIX_EXPORTED_CONST_MESSAGE_1(MY_LIB_API, int, size, int, dimension);
*
* // Two message overloads, that should be bound to:
* // void mixin_class::scale(float uniform);
* // void mixin_class::scale(const vector3& vec);
* // respectively.
* // The macros will generate two functions named scale with the
* // appropriate arguments. In order to bind them to a mixin,
* // you should use scale_uniform_msg and scale_vector_msg
* // in the mixin feature list.
* DYNAMIX_MESSAGE_1_OVERLOAD(scale_uniform, void, scale, float, uniform);
* DYNAMIX_MESSAGE_1_OVERLOAD(scale_vector, void, scale, const vector3&, vec);
* \endcode
*/
#define DYNAMIX_MESSAGE_N(return_type, message, args)

/**
* Macro that defines a message by also providing a default implementation
*
* Use it once per message in a compilation unit (.cpp file)
*
* A default implementation lets the user provide code to be executed if
* a message is called for an object which has no mixin implementing it.
*
* \par Legend:
* - `N` is a number that indicates how many parameters the
* message takes. If `N` is 0, then `args` is omitted.
* - `args` is a coma-separated list of the argument types and argument names of
* the message's arguments
* - `message_name` - is the name of the message
*
* \par Notes:
* - As is the case with the mutation rules, an empty object won't implement default
* message implementations. You'll need at least one mutation to make it do so
* - A default implementation can be treated the same way as your implementation
* in the method for a regular message: ie `dm_this` is valid
* - If any of the mixins in an object implements this message, the default
* implementation will be unreachable. Multicasts won't feature it.
*/
#define DYNAMIX_DEFINE_MESSAGE_N_WITH_DEFAULT_IMPL(return_type, message_name, args)

/**
* The macro for defining a message.
* Use it once per message in a compilation unit (.cpp file)
*/
#define DYNAMIX_DEFINE_MESSAGE(message_name)

#else

// optionally don't include any message macros and let the user decide which
// set they're going to use for each message
#if !defined(DYNAMIX_NO_MESSAGE_MACROS)
// include the generated macros
// choose definition header
// making this choice DOES NOT require you to rebuild the library
// these headers are purely user facing
#if defined(DYNAMIX_USE_LEGACY_MESSAGE_MACROS)
// this file contains the old-style macros which have a lot of the calling code
// in the macros itself. They make it a bit harder to step into messages when
// debugging but in some cases with gcc and clang compile much faster
#   include "gen/legacy_message_macros.hpp"
#else
// these are the new-style message macros only a single step into is needed when
// debugging in order to go to debuggable c++ code
// however they may be much slower to compile on gcc and clang
// this is generally the recommended header, but users are encouraged to test
// their compilation times with gcc and clang with the other header as well
#   include "gen/template_message_macros.hpp"
#endif
#endif

// define message macro
#define DYNAMIX_DEFINE_MESSAGE(message_name) \
    /* create feature getters for the message */ \
    ::dynamix::feature& _dynamix_get_mixin_feature_safe(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
    } \
    const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_fast(); \
    } \
    /* create a feature registrator */ \
    void _dynamix_register_mixin_feature(const I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        ::dynamix::internal::domain::safe_instance(). \
            register_feature(::dynamix::internal::feature_instance<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe()); \
    } \
    /* instantiate metafunction initializator in case no class registers the message */ \
    inline void _dynamix_register_message(I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        ::dynamix::internal::message_registrator<I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::registrator.unused = true; \
    } \
    /* provide a tag instance */ \
    I_DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * I_DYNAMIX_MESSAGE_TAG(message_name)

#endif
